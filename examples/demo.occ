-- Configuration. 1860 is the largest number for which the sum is still
-- representable as a signed 32-bit integer.
CONST NUM.TASKS = 1860,
      NUM.WORKERS = 16 :

-- For aesthetic purposes, define "otherwise" for use in IF statements.
CONST OTHERWISE = TRUE :

-- Squaring worker.
PROC worker(CHAN get.task, CHAN is.done, CHAN send.result) =
  VAR done, task, result :
  SEQ
    done := FALSE
    WHILE NOT done
      ALT
        get.task ? task
          SEQ
            result := task * task
            send.result ! result
        is.done ? done
          SKIP
:

-- Master controller.
PROC master(CHAN send.task[], CHAN signal.done[], CHAN get.result[], VALUE p) =
  VAR done, task, sum :
  SEQ
    -- Initialize the counts.
    done := 0  -- Number of workers that have terminated.
    task := 0  -- Number of tasks that have been handed out.
    sum := 0   -- Total sum of results.
    -- Hand out the initial tasks.
    SEQ i = [0 FOR p]
      SEQ
        task := task + 1
        send.task ! task
    -- Loop until all tasks have been handed out, and every worker has
    -- finished.
    WHILE (task < NUM.TASKS) OR (done < p)
      VAR result :
      ALT i = [0 FOR p]
        -- Handle results being received from workers.
        get.result ? result
          PAR
            sum := sum + result
            IF
              task < NUM.TASKS
                -- Not done yet. Send a new task.
                SEQ
                  task := task + 1
                  send.task[i] ! task
              OTHERWISE
                -- All tasks have been assigned. Terminate this worker.
                PAR
                  signal.done[i] ! TRUE
                  done := done + 1
    -- All tasks have finished. The sum is final.
    print(sum)
:

CHAN tasks[NUM.WORKERS],
     done.signal[NUM.WORKERS],
     results[NUM.WORKERS] :

-- Start the master and the workers on separate machines.
PAR
  PAR i = [0 FOR NUM.WORKERS]
    worker(tasks[i], done.signal[i], results[i])
  master(tasks, done.signal, results)
