== Background, Occam example ==
PROC foo(VALUE a, b, CHAN c, d) =
  PAR i = [0 FOR n]  -- Replicated parallel.
    SEQ              -- Explicit sequence.
      VAR x :        -- Declare variable x.
      bar(x, i)      -- Call procedure bar.
      IF             -- If statement.
        x < b        -- if (x < b) {
          c ! a      --   Output a to channel c.
        x >= b       -- } else if (x >= b) {
          d ! ANY    --   Output something (it doesn't matter what) to d.
:                    -- }

PROC bar(VAR x, VALUE i) =          -- Occam has no operator precedence:
  x := ((i * i) \ (i + i + i)) - i  -- It is necessary to bracket all except
:                                   -- sequences of some associative operator.

CHAN c, d :
VAR x, e, f :
PAR
  foo(-1, 1, c, d)   -- Run the process foo.
  SEQ i = [0 FOR n]  -- Loop n times:
    ALT              -- Alternative: perform one of the following:
      c ? x          -- Read a value x from c.
        e := e + x
      d ? ANY        -- Read something (it doesn't matter what) from d.
        f := f + 1
== Design, semantic error example ==
CHAN c :
SEQ
  c := 2
== Implementation, continuation example ==
x := 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
-- could be rewritten as
x := 1 + 2 + 3 + 4 + 5 +
     6 + 7 + 8 + 9 + 10
== Design, variable-length label encoding example ==
FOO:
  ...
  <500 instructions later>
  ...
  j FOO
== Implementation, Parser monad definition ==
data Parser a b where
  Epsilon :: (Eq a, Eq b) => b -> Parser a b
  Match :: Eq a => String -> (a -> Bool) -> Parser a a
  Union :: (Eq a, Eq b) => [Parser a b] -> Parser a b
  Concat :: (Eq a, Eq b, Eq c) => Parser a b -> Parser a c -> Parser a (b, c)
  Star :: (Eq a, Eq b) => Parser a b -> Parser a [b]
  Reduce :: (Eq a, Eq b, Eq c) => (b -> c) -> Parser a b -> Parser a c
== Implementation, run_parser definition ==
run_parser :: (Eq a, Eq b, Show a) =>
              Parser (Token a) b -> [Token a] -> [Result (b, [Token a])]
== Implementation, infix operator example ==
-- a := b
assign :: Parser Token (L Process)
assign = Reduce (\(a, (_, b)) -> L (Assign a b) (location a))
                (Concat expression (Concat (symbol Lexer.ASSIGN) expression))
-- to be rewritten as
-- a := b
assign :: Parser Token (L Process)
assign = expression +++ symbol Lexer.ASSIGN +++ expression
     >>> (\(a, (_, b)) -> L (Assign a b) (location a))
== Implementation, left recursion operator ==
-- Handle left recursion: this works by turning:
--   parse_a = parse_b
--         ||| parse_a +++ parse_c     >>> f
-- Into:
--   parse_a = left
--               parse_b  -- base case
--               parse_c  -- repeated tail
--               f        -- reducer.
left :: (Eq a, Eq b, Eq c) =>
        Parser a b -> Parser a c -> (b -> c -> b) -> Parser a b
== Appendix, evaluation rules for parsers ==
-- Evaluation rules for parsers. This takes a parser, and a sequence of tokens,
-- and produces a list of possible parse results. Each result is either
-- a success, which means the subtree parsed and parsing can continue, or it is
-- a failure, in which case the subtree did not parse and it may be desirable to
-- display an error message.
--
-- Typical parsers produce a *lot* of redundant results, so it is *extremely*
-- beneficial to remove duplicates. This is why the requirement on Eq is
-- scattered all over the place, and is what 'nub' is doing.
run_parser :: (Eq a, Eq b, Show a) =>
              Parser (Token a) b -> [Token a] -> [Result (b, [Token a])]
run_parser p = nub . run_parser' p

-- Epsilon always successfully parses.
run_parser' :: (Eq a, Eq b, Show a) =>
              Parser (Token a) b -> [Token a] -> [Result (b, [Token a])]
run_parser' (Epsilon x) xs = [Success (x, xs)]

-- A matcher either fails, or succeeds with one parse.
run_parser' (Match m f) [] = [Failure EOF $ "Expected " ++ m]
run_parser' (Match m f) (x:xs) =
  if f x then
    [Success (x, xs)]
  else
    [Failure (token_location x)
             ("Unexpected " ++ show (token_type x))]

-- A union can succeed with any possible parses of any of its constituents.
run_parser' (Union ps) xs = concat . transpose . map (flip run_parser xs) $ ps

-- A concatenation can succeed only for successful parses of the second
-- immediately following any successful parse of the first.
run_parser' (Concat a b) xs =
  run_parser a xs >>= (\result ->
    case result of
      Failure l m -> [Failure l m]
      Success (a', xs') ->
        map (fmap (\(b', xs'') -> ((a', b'), xs''))) $ run_parser b xs')

-- A Klein star can succeed for any number of repetitions of p (even 0).
-- This can never fail, and success gives all matching prefixes.
run_parser' (Star p) xs =
  run_parser p xs >>= (\result ->
    case result of
      Failure l m -> [Success ([], xs), Failure l m]
      Success (a', xs') ->
        run_parser (Star p) xs' >>= (\result' ->
          [result' >>= (\(as', xs'') -> return ((a' : as', xs''))),
           Success ([], xs)]))

-- A reduction succeeds directly when the reduced parser succeeds.
run_parser' (Reduce f p) xs =
  run_parser p xs >>= return . (fmap (\(a, xs') -> (f a, xs')))

-- Run a parser and take the first parse which consumes all input.
full_parse :: (Eq a, Eq b, Show a, Show b) =>
              Parser (Token a) b -> [Token a] -> b
full_parse p xs =
  let ps = run_parser p xs in
    case [full | Success (full, []) <- ps] of
      [] -> error . show $ failure ps
      (x:xs) -> x
== Implementation, old expression grammar ==
expression :: Parser Token (L Expression)
expression = ...                                                 ...
         ||| operand
         ||| operand +++ symbol Lexer.COMP_EQ +++ operand    >>> ...
         ||| operand +++ symbol Lexer.COMP_GE +++ operand    >>> ...
         ||| operand +++ symbol Lexer.COMP_GT +++ operand    >>> ...
         ||| operand +++ symbol Lexer.COMP_LE +++ operand    >>> ...
         ||| operand +++ symbol Lexer.COMP_LT +++ operand    >>> ...
         ||| operand +++ symbol Lexer.COMP_NE +++ operand    >>> ...
         ||| operand +++ symbol Lexer.DIV +++ operand        >>> ...
         ||| operand +++ symbol Lexer.MOD +++ operand        >>> ...
         ||| operand +++ symbol Lexer.SUB +++ operand        >>> ...
             ...                                                 ...
== Implementation, new expression grammar ==
expression :: Parser Token (L Expression)
expression = ...                                                 ...
         ||| operand +++ (
                   Epsilon OPERAND                           >>> ...
               ||| symbol Lexer.COMP_EQ +++ operand          >>> ...
               ||| symbol Lexer.COMP_GE +++ operand          >>> ...
               ||| symbol Lexer.COMP_GT +++ operand          >>> ...
               ||| symbol Lexer.COMP_LE +++ operand          >>> ...
               ||| symbol Lexer.COMP_LT +++ operand          >>> ...
               ||| symbol Lexer.COMP_NE +++ operand          >>> ...
               ||| symbol Lexer.DIV +++ operand              >>> ...
               ||| symbol Lexer.MOD +++ operand              >>> ...
               ||| symbol Lexer.SUB +++ operand              >>> ...
                   ...                                           ...
             )
