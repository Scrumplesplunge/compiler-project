The purpose of this project is to explore the intricacies of compiling an
Occam-like language. Given the highly concurrent nature of Occam, it seems
natural to consider the possibility of making the runtime environment
distributed. This chapter will formally set out the scope of the project, and
address which features will be implemented and with what priority.

\section{Occam Features}

The compiler implemented in this project will aim to implement a large subset of
the functionality of Occam 1, as well as a handful of customisations. Common
language features are not the focus of this project. Instead, interesting
features will be the focus in the compiler, and most of the focus will be aimed
at making the compiler pleasant to use, and on making the runtime environment
featureful and efficient.

\subsection{Language Features}

These are features which could reasonably be considered as fundamental to Occam.
The main features which have been implemented are:
\begin{itemize}
  \item Integer variables.
  \item Channels.
  \item One-dimensional arrays (of integers or channels).
  \item \texttt{SEQ}, \texttt{PAR}, and \texttt{IF} constructs, both with and
        without replication.
  \item \texttt{WHILE} and \texttt{ALT} constructs.
\end{itemize}

In addition to these features, I have implemented an extension to the language,
the \texttt{DIST PAR} construct, which allows the programmer to distribute
a task across an arbitrarily large number of workers. The construct works in the
same way as a PAR construct, but distributes the sub-processes across multiple
machines rather than running them all locally. These processes may not read or
write to variables defined outside their own scope, but they may communicate via
channels that were defined outside their scope. The runtime needed to support
this functionality is described in more detail below.

\subsection{Features Beyond Scope} \label{beyond-scope}

The following Occam features are outside the scope of this project:
\begin{itemize}
  \item Time-related functionality such as timer input or delays.
  \item Procedures, which provide no new functionality to the language.
  \item Replicated \texttt{ALT} constructs.
\end{itemize}
These features are ones which are time-consuming or challenging to implement,
but are not necessary for the compiler to be useful.

\section{Runtime Environment}

The compiler will transform the program source into some executable format. It
is the task of the virtual machine to understand how to run this executable, and
it is the task of the overall runtime environment to allow multiple instances of
the virtual machine to interact with each other.

\subsection{Virtual Machine} \label{vm}

The \textit{\gls{vm}} should be capable of executing code which is intended to
run on a single processor. This does not mean that it is limited to a single
process, however, rather that it will only provide concurrency rather than
parallelism. This will be modelled off the instruction set of the
\gls{transputer}, with appropriate modifications to support the language
extensions described above with the help of the runtime system, and cut back to
include only the instructions that are emitted by the compiler, to reduce
complexity.

\subsection{Distributed Runtime System} \label{dist-system}

Since Occam processes communicate via channels rather than by sharing memory, it
is relatively easy to imagine these channels connecting processes on separate
threads, or even separate machines, through use of traditional approaches such
as atomic memory operations, mutexes, or even network sockets. If some mechanism
for using these more advanced channels was built into the language, then a
programmer could write separate Occam programs for a collection of VM instances,
and have them collaborate. The programmer would have to consider the complexity
of each of the parallel tasks and organise the code such that each of the
instances had a fair share of the load.

However, sometimes it is not possible to predict the load distribution like
this. Factors such as user input or other real-world data could easily change
the load characteristics of the software when values stray from ranges that the
programmer predicted. This is where the language extensions come into play. By
removing the responsibility of placement from the programmer, the runtime system
is able to make that decision based on the properties of each process, and on
the load of each server at that moment. Additionally, this means that a program
can be run on a different number of machines without changing the source code.

For this reason, the runtime system should be capable of supporting
communication between a large number of instances which may span several
machines. When new processes are constructed via the \texttt{DIST PAR}
construct, the runtime system should make an informed decision about
\textit{where} the process should be started. In a production system, it would
be desirable to also handle failure cases such as loss of connection or hardware
failure, but this is beyond the scope of this project: all hardware is assumed
to be perfectly reliable, and all connections are assumed to be unbroken.
